################################################################
-- Триггеры. Задание 1.
-- Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток.
-- С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна
-- возвращать фразу "Добрый день", с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".
-- Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток.
-- С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна
-- возвращать фразу "Добрый день", с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".
################################################################

-- Команда для удаления функции.
DROP FUNCTION IF EXISTS hello;

-- Создадим заготовку для тела функции. 
DELIMITER //
CREATE FUNCTION hello ()
RETURNS TEXT DETERMINISTIC
BEGIN
	RETURN 'Доброе утро';
END//
DELIMITER ;

SELECT hello();
-- Работает, но выводит всегда "доброе утро"
-- Получим количество часов

SELECT HOUR(NOW()); 

-- Добавим условный оператор, который преобразует время в правильный текст, если время в заданном диапазоне.



DELIMITER //
CREATE FUNCTION hello ()
RETURNS TEXT DETERMINISTIC
BEGIN
	IF HOUR(NOW()) BETWEEN 6 AND 11 THEN
		RETURN 'Доброе утро';
	ELSEIF HOUR(NOW()) BETWEEN 12 AND 17 THEN
		RETURN 'Добрый день';
	ELSEIF HOUR(NOW()) BETWEEN 18 AND 23 THEN
		RETURN 'Добрый вечер';
	ELSE
		RETURN 'Доброй ночи'; -- Конструкция HOUR(NOW()) не может вывести некорректное значение, поэтому else
	END IF;
END//
DELIMITER ;

SELECT hello();

-- Можно было ввести переменную, но в данном случае так лучше читается.




################################################################

-- Триггеры. Задание 2.
-- В таблице products есть два текстовых поля: name с названием товара и description
-- с его описанием. Допустимо присутствие обоих полей или одно из них.
-- Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема.
-- Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены.
-- При попытке присвоить полям NULL-значение необходимо отменить операцию.
################################################################

-- Создадим запрос для удаления и "заготовку" для триггера.
DROP TRIGGER IF EXISTS check_id;
DELIMITER //
CREATE TRIGGER check_id BEFORE INSERT ON products
FOR EACH ROW
BEGIN
	
END//
DELIMITER ;

-- Конструкция SELECT INTO доступна только в теле триггера.


DROP TRIGGER IF EXISTS check_id;
DELIMITER //
CREATE TRIGGER check_id BEFORE INSERT ON products
FOR EACH ROW
BEGIN
	DECLARE prod_id, cat_id INT;
	SELECT id INTO prod_id FROM products ORDER BY id LIMIT 1; -- получаем ID и записываем в prod_id по порядку старые значения
	SELECT catalog_id INTO cat_id FROM products ORDER BY id LIMIT 1; -- и старые значения каталога
	IF (COALESCE(NEW.name, NEW.description) IS NULL) THEN  -- Проверяем сначала name затем description
		SET NEW.id = prod_id; 
		SET NEW.catalog_id = cat_id; -- И, если везде null, явно возвращаем id и catalog_id прежнее значение.
	END IF;
END//
DELIMITER ;

INSERT INTO products
  (price, catalog_id)
VALUES (90.00, 1);

SELECT * FROM products;

-- При создании триггера выскакивает ошибка SQL Error [1419] [HY000]:
-- Чтобы оттестировать запрос нужно с ней разобраться. 
-- вроде как ругается на недостаточность привелегий, а они вроде максимальные уже...
-- Сейчас не располагаю временем чтобы разобраться самостоятельно, да и не уверен, что база как-то неправильно настроена 
-- Поэтому сдам в таком виде, и надеюсь семинар и разбор ДЗ поможет разобраться где косячил.

