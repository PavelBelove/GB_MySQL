#########################################################
-- 1. Проанализировать какие запросы могут выполняться наиболее часто в процессе работы приложения и добавить необходимые индексы.
#########################################################


USE GB_VK;
SHOW TABLES;
DESC users;

-- При поиске людей обычно используется и имя, и фамилия. Стоит сделать индекс по этим двум полям. 
-- а так же по e-mail (предполагаю что запрос по номеру телефона не такой частый)

CREATE UNIQUE INDEX users_email_idx ON users(email);

CREATE INDEX users__last_name__first_name_idx ON users(last_name, first_name); -- Сортировка по фамилии важнее сортировки по имени.
#########################################################

DESC communities;

-- создам индекс по имени.
CREATE UNIQUE INDEX communities_name_idx ON communities(name); -- создание копий сообществ обычно не очень хорошие цели преследует. 
#########################################################
DESC communities_users; -- ничего не требуется.
DESC friendship; -- ничего не требуется, 'status_id' вряд ли будет часто требоваться для сортировки.
DESC friendship_statuses; -- не создаю, т.к. таблица маленькая. Если бы возникли проблемы в этом месте, я бы вообще от нее избавился, 
-- откорректировав friendship.status с прямо указанными значениями.


#########################################################
DESC likes;
-- Индексы для 'user_id', 'target_id'

CREATE UNIQUE INDEX likes__target_id_idx ON likes(target_id); -- Цели уникальны
CREATE INDEX likes__user_id_idx ON likes(user_id); -- а пользователи нет.

-- Если 'target_type_id' грузит базу - тут вряд ли поможет индекс, скорее виной многотабличность запроса.
-- Тут вопрос резонный возник: 
-- Сменить 'target_type_id' на 'target_type', указав значения прямо, потребует переписи многих уже существующих запросов.
-- Но если просто напрямую укаать, ничего не меняя,

SELECT * FROM likes WHERE target_type_id = 1 LIMIT 10;

-- То все работает, без привлечения дополнительной таблицы. Правда, до тех пор пока таблица типов не меняется.
-- А по логике базы вряд ли когда-то должен пропасть тип контента, уже присутствующий в соцсети.
-- Добавляться - возможно, удаляться и меняться - никогда.
-- Можно ли применять такой подход, например, навесив триггеры запрещающие удалять и менять строки в target_types?

#########################################################
DESC media;
-- Индексы для 'user_id', 'filename'

CREATE INDEX media__filename_idx ON media(filename); 
CREATE INDEX media__user_id_idx ON media(user_id); 
#########################################################
-- Далее не стал, т.к. сильно во времени ограничен, логика та же - индексы создаются для тех полей, которые не являются первичным ключом
-- и обращение к которым наиболее вероятно в запросах "от пользователей", то есть с фронта. Либо в регулярных запросах, сильно грузящих базу.
#########################################################

