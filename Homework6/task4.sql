-- 4. Найти 10 пользователей, которые проявляют наименьшую активность в использовании социальной сети.

-- Для реальной базы такие параметры как заполненность профиля и дата последнего посещения играли бы ключевую роль.
-- Но в учебной базе далеко не все юзеры имеют фото, а дата обновления сгенерирована случайно,
-- Поэтому здесь допускаем, что все пользователи в выборке заходили на сайт в последнее время,
-- критериями сортировки выборки будут в первую очередь количество друзей - те, кто не генерирует контент наименее активны.
-- Вторым уровнем проверки будут лайки. Пользователи, которые не только не пишут посты но и наименее активно реагируют на уже существующий
-- контент точно подходят под определение "наименее активных"

-- Отсортируем пользователей по кол-ву лайков.
SELECT * FROM likes LIMIT 5;
SELECT * FROM users LIMIT 5;

SELECT 
	id,
	(SELECT 
		COUNT(id) 
		FROM likes 
		WHERE user_id = users.id) 
		AS 'total_likes'
	FROM users
	ORDER BY total_likes
	LIMIT 10; 

--  В принципе, получены 10 записей с нулем лайков. Таких полозователей больше, и не ясно, являются ли эти действительно, наименее активными.
-- Создадим аналогичный запрос, по кол-ву друзей.
-- Причем в данном контексте меня скорее интересуют те друзья, инициатором  общения с которыми является данный юзер.
-- Ведь в этом случае уровень "активности" гораздо выше - пользователь заводит друзей. Это не то же самое, что одобрить поступившие заявки.
-- поэтому меня интересуют friend_id соответствующего юзера, "в зачет" идут так же отправленные заявки в друзья.
SHOW TABLES;
SELECT * FROM friendship;

SELECT COUNT(friend_id) 
  FROM friendship 
  WHERE user_id = 23 AND status_id IN (
      SELECT 
      id 
      FROM friendship_statuses 
      WHERE name = 'Confirmed' OR name = 'Requested'
  );
   
 -- Теперь обернем получившийся запрос поиском по users
 -- данные сортируем по полям, от важных к менее важным. 
 

 
 #########################################################################################
 
 
SELECT 
	id,
	(SELECT 
		COUNT(id) 
		FROM likes 
		WHERE user_id = users.id) 
		AS 'total_likes',
	(SELECT COUNT(friend_id) 
  		FROM friendship 
  		WHERE user_id = users.id AND status_id IN (
      		SELECT 
     			id 
      			FROM friendship_statuses 
      			WHERE name = 'Confirmed' OR name = 'Requested'
  	)) 
  	AS 'friendship_orders'
	FROM users
	ORDER BY total_likes, friendship_orders
	LIMIT 10; 

-- Теперь в результатах поиска только пользователи с нулевыми лайками и не отправившие ни одной заявки в друзья.
-- По аналогии можно накидать выборок по очень большому количеству параметров.
-- Слабая сторона подхода в наличии четкой иерархии - сначала сортировка по лайкам, потом по друзьям
-- Зато порядок этой сортировки легко менять, переставляя имена полей после ORDER BY.

########################################################################################

-- Еще один подход, действующий более гибко, но требующий изменения структуры базы.
-- добавить глобально пользователям рейтинг активности, создав соответствующее поле в profiles
-- Тогда можно будет последовательно выполнить любое количество запросов, высчитывающими рейтинг по любой логике, например:
-- любой чих пользователя можно получить запросом, аналогичным предыдущим. Полученное значение умножить на коэффициент (насколько полученная цифра
-- важна для анализа активности). Обновить значение поля raiting в profiles, прибавив к уже существующему значению результаты выдачи.
-- (При каждом новом пересчете поле обнуляется) Настраивая коэффициенты и комбинируя необходимые простые запросы, можно будет
-- заполнить поле raiting чтобы учитывались сразу множество факторов, в любых комбинациях и каждый со своей "силой".
-- То, что каждый вид активности отрабатывается отдельным запросом, позволит на этом этапе отслеживать, например, накрутки, или активность ботов.

-- Вообще, я бы, пожалуй сделал рейтинг активности не только как техническую сущность, а дал пользователю возможность видеть его хотя бы в профайле. 
-- С возможностью дать публичный доступ добровольно. Убывающие цифры мотивируют проявлять большую активность. 
-- Как и возможность посоревноваться, выставить это "достижение" на показ. Но реализация этого требует минимум еще одного поля is_public 
-- принимающего TRUE И FALSE - хочет ли юзер чтобы его счетчик видели другие. 


-- Понятно, что при таком подходе решение задачи сведется к простейшему запросу:
SELECT * FROM profiles ORDER BY 'raiting' DESC LIMIT 10; 

-- Ну и, раз уж перекраивать базу, стоит подготовить колонку-другую (или таблицу, смотря насколько это важно) для еще одного "мерила" активности - 
-- отслеживания пользовательского времени, проведенного на сайте. Сколько раз за последнюю неделю заходил? Вечером час просидел, или тот же час набрал
-- с телефона, по 2 минуты в течение дня? В какое время суток и по дням недели максимальная/минимальная активность? Часть этих данных можно достать из существующих
-- таблиц. Но для точечной аналитики этой информации маловато. 

-- Базу это дополнительно нагрузит. Поэтому вероятно, не стоит собирать такую аналитику прямо по всем пользователям, всем действиям.
-- Видится создание дополнительной таблицы для отслеживания 
-- пользовательского времени, но поскольку мы собираем данные для аналитики, а не устраиваем тотальную слежку, данные лучше тоже оформить в виде рейтинга-времени, который
-- постоянно уменьшается, если пользователь бездействует и увеличивается, если активен. 

-- Либо же, снабдить графу рейтинг свойством уменьшаться со временем. Если рейтинг пересчитывается регулярно, такой подход сработает и будет
-- выдавать правдоподобные результаты. Мы выиграем в быстродействии и простоте, но потеряем часть возможностей для анализа. Нужно тогда
-- сохранять хотя бы выборочно предыдущие значения рейтинга на каждого пользователя. 


-- Первый пришедший в голову подход - сделать несколько "рейтингов" - за год, месяц, неделю, день. Высчитываются они одинаковыми запросами, но обнуляются
-- в Новый Год, Понедельник, полночь. Так можно будет собирать статистику в привязке к календарным датам. 
-- Второй вариант - сделать для всех "рейтингов" разную функцию уменьшения во времени. Чтобы годовой в полночь "худел" на 1/365 а суточный - обнулялся. 
-- Так всегда будут актуальные, но приблизительные данные. 
-- Такие заморочки нужны ради статистики, если "привести к общему знаменателю"  все рейтинги пользователя (годовой на 365 поделить, или количество дней с регистрации). 
-- Недельный - на 7 и т.д., то можно отслеживать изменение активности любого пользователя. Если все значения возрастают, пользователь активен и "раскручивает" аккаунт.
-- Если недельный и дневной рейтинги вдруг просели - в жизни пользователя появились другие заботы. Пора отправить ему письмо с лентой новостей друзей...
